<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Toastie UTS Tool</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css"
      integrity="sha512-cyzxRvewl+FOKTtpBzYjW6x6IAYUCZy3sGP40hn+DQkqeluGRCax7qztK2ImL64SA+C7kVWdLI6wvdlStawhyw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      /* Grid container: left for tile selector; right for sample image and room preview */
      #gridContainer {
        display: grid;
        grid-template-columns: 1fr 800px;
        gap: 20px;
      }
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #2c2c2c;
        color: #eee;
        margin: 20px;
      }
      h1, h2, p {
        margin: 10px 0;
      }
      /* Left column: tile selector using flex-wrap */
      #leftColumn {
        overflow-y: auto;
        max-height: 90vh;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      .tileSection {
        width: 300px;
        margin-bottom: 10px;
        padding: 10px;
        background: #333;
        border-radius: 4px;
      }
      .tileSection h3 {
        margin-bottom: 8px;
      }
      .tileRow {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
      }
      .tileCell {
        width: 80px;
        height: 80px;
        background: #444;
        border: 2px solid #555;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.1s;
        position: relative;
      }
      .tileCell:hover {
        transform: scale(1.05);
      }
      .tileCell img {
        max-width: 100%;
        max-height: 100%;
        border-radius: 2px;
      }
      .seamlessTypeBtn, #addTileTypeBtn {
        width: 100%;
        margin-top: 8px;
        padding: 4px 8px;
        font-size: 12px;
        background: #007acc;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
      }
      .seamlessTypeBtn:hover, #addTileTypeBtn:hover {
        background: #005f99;
      }
      /* Right column: contains sample controls, sample image, then room preview */
      #rightColumn {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      #sampleContainer {
        position: relative;
        border: 2px solid #444;
        border-radius: 4px;
        padding: 10px;
      }
      /* Sample controls at the top */
      #sampleControls {
        margin-bottom: 10px;
      }
      #sampleControls select,
      #sampleControls input[type="file"] {
        width: 100%;
        margin-bottom: 5px;
      }
      #imagePreviewContainer {
        position: relative;
        display: block;
      }
      #imagePreview {
        display: block;
        width: 100%;
        height: auto;
        max-height: 300px;
      }
      /* Crop controls overlay */
      #nudgeControlsContainer {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .nudgeArrow, #confirmCropBtn, #unlockCropSizeBtn {
        position: absolute;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        padding: 5px 8px;
        font-size: 16px;
        pointer-events: all;
        transition: background 0.2s;
      }
      .nudgeArrow:hover, #confirmCropBtn:hover, #unlockCropSizeBtn:hover {
        background: #ddd;
      }
      #nudgeUp {
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #nudgeDown {
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #nudgeLeft {
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #nudgeRight {
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #confirmCropBtn {
        bottom: 5px;
        right: 5px;
        background: #4caf50;
        color: #fff;
      }
      #unlockCropSizeBtn {
        bottom: 45px;
        right: 5px;
        background: #f0ad4e;
        color: #fff;
        display: none;
      }
      /* Room preview container */
      #roomPreviewContainer {
        position: relative;
      }
      #roomPreviewCanvas {
        border: 2px solid #444;
        border-radius: 4px;
      }
      /* Scrollbar for left column */
      #leftColumn::-webkit-scrollbar {
        width: 8px;
      }
      #leftColumn::-webkit-scrollbar-track {
        background: #333;
        border-radius: 4px;
      }
      #leftColumn::-webkit-scrollbar-thumb {
        background: #666;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>Toastie UTS Tool</h1>
    <div id="gridContainer">
      <div id="leftColumn">
        <!-- Tile Selector -->
        <div id="tileSelector">
          <h2>Tile Variants</h2>
          <!-- Example tile section: Floor (other sections omitted for brevity) -->
          <div class="tileSection" data-tile-type="Floor">
            <h3>Floor</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="Floor" data-variation="1"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="2"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="3"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="4"></div>
            </div>
            <button class="seamlessTypeBtn" data-tile-type="Floor">Make Seamless</button>
          </div>
          <!-- (Other tile sections for NorthWall, SouthWall, Door, DoorFrame, inner corners, etc.) -->
          <div class="tileSection" data-tile-type="Pillar">
            <h3>Pillar (Auto‑Composite)</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="Pillar" data-variation="1"></div>
            </div>
            <button class="seamlessTypeBtn" data-tile-type="Pillar">Update Pillar</button>
          </div>
          <button id="addTileTypeBtn">Add New Tile Type</button>
        </div>
      </div>
      <div id="rightColumn">
        <!-- Sample Image Container with Controls -->
        <div id="sampleContainer">
          <div id="sampleControls">
            <p>Select a sample image or upload your own:</p>
            <select id="sampleImages">
              <option value="">-- Select Sample Image --</option>
              <option value="images/sample1.png">Sample 1</option>
              <option value="images/sample2.png">Sample 2</option>
            </select>
            <input type="file" id="uploadImage" accept="image/*">
          </div>
          <div id="imagePreviewContainer">
            <img id="imagePreview" src="" alt="Source Image" />
            <div id="nudgeControlsContainer">
              <button id="nudgeUp" class="nudgeArrow">↑</button>
              <button id="nudgeDown" class="nudgeArrow">↓</button>
              <button id="nudgeLeft" class="nudgeArrow">←</button>
              <button id="nudgeRight" class="nudgeArrow">→</button>
              <button id="confirmCropBtn">Confirm Crop</button>
              <button id="unlockCropSizeBtn">Unlock Crop Size</button>
            </div>
          </div>
        </div>
        <!-- Room Preview -->
        <div id="roomPreviewContainer">
          <h2>Room Preview</h2>
          <p>
            The preview uses a multi‑ring layout.
            Outer ring uses walls, corners, doors, and door frames.
            The inner room is a 2×2 square with:
            (4,4): InnerTopLeft; (4,5): InnerTopRight;
            (5,4): InnerBottomLeft; (5,5): InnerBottomRight.
            The Pillar tile (auto‑composite) appears if available.
          </p>
          <canvas id="roomPreviewCanvas" width="800" height="800"></canvas>
        </div>
      </div>
    </div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"
      integrity="sha512-6lplKUSl86rUVprDIjiW8DuOniNX8UDoRATqZSds/7t6zCQZfaCe3e5zcGaQwxa8Kpn5RTM9Fvl3X2lLV4grPQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        let currentImage = null;
        let cropper = null;
        let selectedTileCell = null;
        let lastCropData = null;
        window.tilesetMetadata = {};
        window.defaultTileSizes = {};
        let cropSizeLocked = false;

        const imagePreview = document.getElementById('imagePreview');
        const sampleImagesSelect = document.getElementById('sampleImages');
        const uploadImageInput = document.getElementById('uploadImage');
        const roomPreviewCanvas = document.getElementById('roomPreviewCanvas');
        const nudgeUpBtn = document.getElementById('nudgeUp');
        const nudgeDownBtn = document.getElementById('nudgeDown');
        const nudgeLeftBtn = document.getElementById('nudgeLeft');
        const nudgeRightBtn = document.getElementById('nudgeRight');
        const confirmCropBtn = document.getElementById('confirmCropBtn');
        const nudgeControlsContainer = document.getElementById('nudgeControlsContainer');
        const unlockCropSizeBtn = document.getElementById('unlockCropSizeBtn');
        const addTileTypeBtn = document.getElementById('addTileTypeBtn');
        const tileSelector = document.getElementById('tileSelector');

        const INITIAL_AUTO_CROP_AREA = 0.085;

        sampleImagesSelect.addEventListener('change', function() {
          if (this.value) {
            imagePreview.src = this.value;
            imagePreview.style.display = 'block';
            currentImage = imagePreview;
          }
        });

        uploadImageInput.addEventListener('change', function() {
          const file = this.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
              imagePreview.src = e.target.result;
              imagePreview.style.display = 'block';
              currentImage = imagePreview;
            };
            reader.readAsDataURL(file);
          }
        });

        document.querySelectorAll('.tileCell').forEach(cell => {
          cell.addEventListener('click', function() {
            if (cropper && selectedTileCell && selectedTileCell !== this) {
              confirmCrop();
            }
            selectedTileCell = this;
            openCropMode();
          });
        });

        function openCropMode() {
          nudgeControlsContainer.style.display = 'block';
          if (cropper) cropper.destroy();
          cropper = new Cropper(imagePreview, {
            aspectRatio: 1,
            viewMode: 1,
            autoCropArea: INITIAL_AUTO_CROP_AREA,
            cropBoxResizable: !cropSizeLocked,
            ready() {
              const tileType = selectedTileCell.getAttribute('data-tile-type');
              const variation = selectedTileCell.getAttribute('data-variation');
              const variantIndex = parseInt(variation) - 1;
              let storedCropData = null;
              if (
                window.tilesetMetadata[tileType] &&
                window.tilesetMetadata[tileType].variations[variantIndex] &&
                window.tilesetMetadata[tileType].variations[variantIndex].cropData
              ) {
                storedCropData = window.tilesetMetadata[tileType].variations[variantIndex].cropData;
              } else if (lastCropData) {
                storedCropData = lastCropData;
              }
              if (storedCropData) {
                cropper.setData(storedCropData);
              }
            }
          });
        }

        if (unlockCropSizeBtn) {
          unlockCropSizeBtn.addEventListener('click', function() {
            cropSizeLocked = false;
            openCropMode();
            unlockCropSizeBtn.style.display = 'none';
          });
        }

        function refreshActiveTilePreview() {
          if (cropper && selectedTileCell) {
            let canvas = cropper.getCroppedCanvas();
            const newImage = canvas.toDataURL('image/png');
            selectedTileCell.innerHTML = '<img src="' + newImage + '" alt="Tile Variant">';
            const tileType = selectedTileCell.getAttribute('data-tile-type');
            const variantIndex = parseInt(selectedTileCell.getAttribute('data-variation')) - 1;
            window.tilesetMetadata[tileType] = window.tilesetMetadata[tileType] || { variations: [] };
            window.tilesetMetadata[tileType].variations[variantIndex] = {
              variation: selectedTileCell.getAttribute('data-variation'),
              imageData: newImage,
              width: canvas.width,
              height: canvas.height,
              cropData: cropper.getData(true)
            };
            if (["InnerTopLeft", "InnerTopRight", "InnerBottomLeft", "InnerBottomRight"].includes(tileType)) {
              updatePillarTile();
            }
            updateRoomPreview();
          }
        }

        nudgeUpBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.y -= 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeDownBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.y += 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeLeftBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.x -= 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeRightBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.x += 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });

        confirmCropBtn.addEventListener('click', confirmCrop);

        function confirmCrop() {
          if (cropper) {
            let canvas = cropper.getCroppedCanvas();
            const tileType = selectedTileCell.getAttribute('data-tile-type');
            const cropData = cropper.getData(true);
            lastCropData = cropData;
            if (!window.defaultTileSizes[tileType]) {
              window.defaultTileSizes[tileType] = { width: canvas.width, height: canvas.height };
            } else {
              const defaultWidth = window.defaultTileSizes[tileType].width;
              const defaultHeight = window.defaultTileSizes[tileType].height;
              if (canvas.width !== defaultWidth || canvas.height !== defaultHeight) {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = defaultWidth;
                offCanvas.height = defaultHeight;
                const offCtx = offCanvas.getContext('2d');
                offCtx.drawImage(canvas, 0, 0, defaultWidth, defaultHeight);
                canvas = offCanvas;
              }
            }
            const croppedDataUrl = canvas.toDataURL('image/png');
            selectedTileCell.innerHTML = '<img src="' + croppedDataUrl + '" alt="Tile Variant">';
            const tileTypeKey = selectedTileCell.getAttribute('data-tile-type');
            window.tilesetMetadata[tileTypeKey] = window.tilesetMetadata[tileTypeKey] || { variations: [] };
            const variantIndex = parseInt(selectedTileCell.getAttribute('data-variation')) - 1;
            window.tilesetMetadata[tileTypeKey].variations[variantIndex] = {
              variation: selectedTileCell.getAttribute('data-variation'),
              imageData: croppedDataUrl,
              width: canvas.width,
              height: canvas.height,
              cropData: cropData
            };
            cropSizeLocked = true;
            if (unlockCropSizeBtn) {
              unlockCropSizeBtn.style.display = 'block';
            }
            cropper.destroy();
            cropper = null;
            nudgeControlsContainer.style.display = 'none';
            if (["InnerTopLeft", "InnerTopRight", "InnerBottomLeft", "InnerBottomRight"].includes(tileTypeKey)) {
              updatePillarTile();
            }
            updateRoomPreview();
          }
        }

        function applySeamlessTilingForType(tileType) {
          if (window.tilesetMetadata[tileType] && window.tilesetMetadata[tileType].variations) {
            window.tilesetMetadata[tileType].variations.forEach((variant, index) => {
              if (variant.imageData) {
                applySeamlessTiling(variant.imageData, function(newDataUrl) {
                  variant.imageData = newDataUrl;
                  document.querySelectorAll('.tileCell[data-tile-type="' + tileType + '"][data-variation="' + (index + 1) + '"]').forEach(cell => {
                    cell.innerHTML = '<img src="' + newDataUrl + '" alt="Tile Variant">';
                  });
                  updateRoomPreview();
                });
              }
            });
          }
        }

        function applySeamlessTiling(imageDataUrl, callback) {
          const img = new Image();
          img.src = imageDataUrl;
          img.onload = function() {
            const w = img.naturalWidth;
            const h = img.naturalHeight;
            const offCanvas = document.createElement('canvas');
            offCanvas.width = w * 3;
            offCanvas.height = h * 3;
            const offCtx = offCanvas.getContext('2d');
            for (let i = 0; i < 3; i++) {
              for (let j = 0; j < 3; j++) {
                offCtx.drawImage(img, i * w, j * h, w, h);
              }
            }
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = w;
            finalCanvas.height = h;
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(offCanvas, w, h, w, h, 0, 0, w, h);
            callback(finalCanvas.toDataURL('image/png'));
          }
        }

        function drawCheckeredBackground(ctx, width, height, tileSize) {
          const lightColor = "#555";
          const darkColor = "#333";
          for (let y = 0; y < height; y += tileSize) {
            for (let x = 0; x < width; x += tileSize) {
              const isDark = ((x / tileSize) + (y / tileSize)) % 2 === 0;
              ctx.fillStyle = isDark ? darkColor : lightColor;
              ctx.fillRect(x, y, tileSize, tileSize);
            }
          }
        }

        function updatePillarTile() {
          const pillarKey = "Pillar";
          const defaultSize = window.defaultTileSizes["Floor"] || { width: 80, height: 80 };
          const topLeft = window.tilesetMetadata["InnerTopLeft"]?.variations?.[0]?.imageData;
          const topRight = window.tilesetMetadata["InnerTopRight"]?.variations?.[0]?.imageData;
          const bottomLeft = window.tilesetMetadata["InnerBottomLeft"]?.variations?.[0]?.imageData;
          const bottomRight = window.tilesetMetadata["InnerBottomRight"]?.variations?.[0]?.imageData;
          if (!topLeft || !topRight || !bottomLeft || !bottomRight) return;
          
          const canvas = document.createElement('canvas');
          canvas.width = defaultSize.width;
          canvas.height = defaultSize.height;
          const ctx = canvas.getContext('2d');
          const halfW = defaultSize.width / 2;
          const halfH = defaultSize.height / 2;
          let pending = 4;
          function done() {
            pending--;
            if (pending === 0) {
              const composite = canvas.toDataURL('image/png');
              window.tilesetMetadata[pillarKey] = window.tilesetMetadata[pillarKey] || { variations: [] };
              window.tilesetMetadata[pillarKey].variations[0] = {
                variation: "1",
                imageData: composite,
                width: canvas.width,
                height: canvas.height,
                cropData: null
              };
              document.querySelectorAll('.tileCell[data-tile-type="Pillar"][data-variation="1"]').forEach(cell => {
                cell.innerHTML = '<img src="' + composite + '" alt="Tile Variant">';
              });
              updateRoomPreview();
            }
          }
          function drawQuarter(src, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight, callback) {
            const img = new Image();
            img.src = src;
            img.onload = function() {
              ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
              callback();
            };
          }
          // Use exact diagonal quarters:
          drawQuarter(topLeft, 0, 0, halfW, halfH, 0, 0, halfW, halfH, done);
          drawQuarter(topRight, defaultSize.width - halfW, 0, halfW, halfH, halfW, 0, halfW, halfH, done);
          drawQuarter(bottomLeft, 0, defaultSize.height - halfH, halfW, halfH, 0, halfH, halfW, halfH, done);
          drawQuarter(bottomRight, defaultSize.width - halfW, defaultSize.height - halfH, halfW, halfH, halfW, halfH, halfW, halfH, done);
        }

        function updateRoomPreview() {
          if (!roomPreviewCanvas) return;
          const ctx = roomPreviewCanvas.getContext('2d');
          const gridSize = 9;
          const tileSize = window.defaultTileSizes["Floor"] ? window.defaultTileSizes["Floor"].width : 80;
          roomPreviewCanvas.width = gridSize * tileSize;
          roomPreviewCanvas.height = gridSize * tileSize;
          ctx.clearRect(0, 0, roomPreviewCanvas.width, roomPreviewCanvas.height);
          // Draw checkered background so transparency is visible.
          drawCheckeredBackground(ctx, roomPreviewCanvas.width, roomPreviewCanvas.height, tileSize);
          
          for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
              let tileType = "Floor";
              if (r === 0) {
                if (c === 0) tileType = "NorthwestCorner";
                else if (c === gridSize - 1) tileType = "NortheastCorner";
                else if (c === Math.floor(gridSize / 2)) tileType = "Door";
                else if (c === Math.floor(gridSize / 2) - 1 || c === Math.floor(gridSize / 2) + 1) tileType = "DoorFrame";
                else tileType = "NorthWall";
              } else if (r === gridSize - 1) {
                if (c === 0) tileType = "SouthwestCorner";
                else if (c === gridSize - 1) tileType = "SoutheastCorner";
                else if (c === Math.floor(gridSize / 2)) tileType = "Door";
                else if (c === Math.floor(gridSize / 2) - 1 || c === Math.floor(gridSize / 2) + 1) tileType = "DoorFrame";
                else tileType = "SouthWall";
              } else if (c === 0) {
                if (r === Math.floor(gridSize / 2)) tileType = "Door";
                else if (r === Math.floor(gridSize / 2) - 1 || r === Math.floor(gridSize / 2) + 1) tileType = "DoorFrame";
                else tileType = "WestWall";
              } else if (c === gridSize - 1) {
                if (r === Math.floor(gridSize / 2)) tileType = "Door";
                else if (r === Math.floor(gridSize / 2) - 1 || r === Math.floor(gridSize / 2) + 1) tileType = "DoorFrame";
                else tileType = "EastWall";
              } else if (r >= 4 && r <= 5 && c >= 4 && c <= 5) {
                if (r === 4 && c === 4) tileType = "InnerTopLeft";
                else if (r === 4 && c === 5) tileType = "InnerTopRight";
                else if (r === 5 && c === 4) tileType = "InnerBottomLeft";
                else if (r === 5 && c === 5) tileType = "InnerBottomRight";
              } else {
                // Fallback to Floor for any cell without explicit assignment.
                tileType = "Floor";
              }
              let variants = window.tilesetMetadata[tileType]?.variations;
              let variant = null;
              if (variants && variants.length > 0) {
                variant = variants[Math.floor(Math.random() * variants.length)].imageData;
              }
              // If no variant found for a non-Floor type, fallback to Floor if available.
              if (!variant && tileType !== "Floor" && window.tilesetMetadata["Floor"]?.variations?.length > 0) {
                variant = window.tilesetMetadata["Floor"].variations[0].imageData;
              }
              const x = c * tileSize;
              const y = r * tileSize;
              if (variant) {
                const img = new Image();
                img.src = variant;
                img.onload = (function(x, y) {
                  return function() {
                    ctx.drawImage(this, x, y, tileSize, tileSize);
                  };
                })(x, y);
              } else {
                // If still missing, draw the tile type as text.
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.font = "12px Segoe UI";
                ctx.fillText(tileType, x + 5, y + 15);
              }
            }
          }
        }

        document.addEventListener('click', function(e) {
          if (cropper && !e.target.closest('#imagePreviewContainer') && !e.target.closest('.tileCell')) {
            confirmCrop();
          }
        });

        addTileTypeBtn.addEventListener('click', function() {
          const newType = prompt("Enter the new tile type name:");
          if (newType && newType.trim() !== "") {
            const section = document.createElement('div');
            section.className = 'tileSection';
            section.setAttribute('data-tile-type', newType);
            const header = document.createElement('h3');
            header.textContent = newType;
            section.appendChild(header);
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            const row = document.createElement('div');
            row.className = 'tileRow';
            for (let i = 1; i <= 4; i++) {
              const cell = document.createElement('div');
              cell.className = 'tileCell';
              cell.setAttribute('data-tile-type', newType);
              cell.setAttribute('data-variation', i);
              row.appendChild(cell);
              cell.addEventListener('click', function() {
                if (cropper && selectedTileCell && selectedTileCell !== this) {
                  confirmCrop();
                }
                selectedTileCell = this;
                openCropMode();
              });
            }
            container.appendChild(row);
            const seamlessBtn = document.createElement('button');
            seamlessBtn.className = 'seamlessTypeBtn';
            seamlessBtn.setAttribute('data-tile-type', newType);
            seamlessBtn.textContent = 'Make Seamless';
            container.appendChild(seamlessBtn);
            section.appendChild(container);
            tileSelector.appendChild(section);
            seamlessBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              applySeamlessTilingForType(newType);
            });
          }
        });
      });
    </script>
  </body>
</html>
