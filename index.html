<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Toastie UTS Tool</title>
    <!-- 
      Using rpg-name-generator from unpkg:
      https://www.npmjs.com/package/rpg-name-generator
      (c) Open source under MIT license.
    -->
    <script src="https://unpkg.com/rpg-name-generator@1.0.2/dist/rpg-name-generator.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css"
      integrity="sha512-cyzxRvewl+FOKTtpBzYjW6x6IAYUCZy3sGP40hn+DQkqeluGRCax7qztK2ImL64SA+C7kVWdLI6wvdlStawhyw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      /* Grid container: left for tile selector; right for sample image, room preview, and save/load controls */
      #gridContainer {
        display: grid;
        grid-template-columns: 1fr 800px;
        gap: 20px;
      }
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #2c2c2c;
        color: #eee;
        margin: 20px;
      }
      h1, h2, p {
        margin: 10px 0;
      }
      /* Left column: arrange tile sections in a CSS grid */
      #tileSelector {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 10px;
      }
      .tileSection {
        background: #333;
        border-radius: 4px;
        padding: 10px;
        position: relative;
      }
      .tileSection h3 {
        margin-bottom: 8px;
      }
      .tileRow {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
      }
      .tileCell {
        width: 80px;
        height: 80px;
        background: #444;
        border: 2px solid #555;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: transform 0.1s;
      }
      .tileCell:hover {
        transform: scale(1.05);
      }
      .tileCell img {
        max-width: 100%;
        max-height: 100%;
        border-radius: 2px;
      }
      /* Clear button (only added once a tile is set) */
      .clearButton {
        position: absolute;
        top: 2px;
        right: 2px;
        background: rgba(255, 0, 0, 0.8);
        border: none;
        color: #fff;
        font-size: 10px;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        cursor: pointer;
        z-index: 2;
      }
      /* "Add New Tile Type" button */
      #addTileTypeBtn {
        width: 100%;
        margin-top: 8px;
        padding: 4px 8px;
        font-size: 12px;
        background: #007acc;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
      }
      #addTileTypeBtn:hover {
        background: #005f99;
      }
      /* Right column: sample image, room preview, and save/load controls */
      #rightColumn {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      #sampleContainer {
        position: relative;
        border: 2px solid #444;
        border-radius: 4px;
        padding: 10px;
      }
      /* Sample controls */
      #sampleControls {
        margin-bottom: 10px;
      }
      #sampleControls select,
      #sampleControls input[type="file"] {
        width: 100%;
        margin-bottom: 5px;
      }
      #imagePreviewContainer {
        position: relative;
        display: block;
      }
      /* Double size sample image */
      #imagePreview {
        display: block;
        width: 100%;
        height: auto;
        max-height: 600px;
        object-fit: contain;
      }
      /* Crop controls overlay */
      #nudgeControlsContainer {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .nudgeArrow, #confirmCropBtn, #unlockCropSizeBtn {
        position: absolute;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        padding: 5px 8px;
        font-size: 16px;
        pointer-events: all;
        transition: background 0.2s;
      }
      .nudgeArrow:hover, #confirmCropBtn:hover, #unlockCropSizeBtn:hover {
        background: #ddd;
      }
      #nudgeUp {
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #nudgeDown {
        bottom: 5px;
        left: 50%;
        transform: translateX(-50%);
      }
      #nudgeLeft {
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #nudgeRight {
        right: 5px;
        top: 50%;
        transform: translateY(-50%);
      }
      #confirmCropBtn {
        bottom: 5px;
        right: 5px;
        background: #4caf50;
        color: #fff;
      }
      #unlockCropSizeBtn {
        bottom: 45px;
        right: 5px;
        background: #f0ad4e;
        color: #fff;
        display: none;
      }
      /* Room preview */
      #roomPreviewContainer {
        position: relative;
      }
      /* Double size preview canvas */
      #roomPreviewCanvas {
        border: 2px solid #444;
        border-radius: 4px;
      }
      /* Save/Load Controls */
      #saveControls {
        margin-top: 10px;
      }
      #tilesetName {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        border-radius: 4px;
        border: 1px solid #555;
        margin-bottom: 5px;
      }
      /* New Random Name button */
      #randomNameBtn {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        background: #008000;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        margin-bottom: 5px;
      }
      #randomNameBtn:hover {
        background: #005000;
      }
      #saveTilesetBtn,
      #loadTilesetBtn {
        width: 100%;
        padding: 6px;
        font-size: 14px;
        background: #007acc;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        margin-bottom: 5px;
      }
      #saveTilesetBtn:hover,
      #loadTilesetBtn:hover {
        background: #005f99;
      }
      #loadTilesetInput {
        display: none;
      }
      /* Left column scrollbar */
      #leftColumn {
        overflow-y: auto;
      }
      #leftColumn::-webkit-scrollbar {
        width: 8px;
      }
      #leftColumn::-webkit-scrollbar-track {
        background: #333;
        border-radius: 4px;
      }
      #leftColumn::-webkit-scrollbar-thumb {
        background: #666;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>Toastie UTS Tool</h1>
    <div id="gridContainer">
      <div id="leftColumn">
        <div id="tileSelector">
          <h2>Tile Variants</h2>
          <!-- All tile sections -->
          <!-- Floor -->
          <div class="tileSection" data-tile-type="Floor">
            <h3>Floor</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="Floor" data-variation="1"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="2"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="3"></div>
              <div class="tileCell" data-tile-type="Floor" data-variation="4"></div>
            </div>
          </div>
          <!-- NorthWall -->
          <div class="tileSection" data-tile-type="NorthWall">
            <h3>NorthWall</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="NorthWall" data-variation="1"></div>
              <div class="tileCell" data-tile-type="NorthWall" data-variation="2"></div>
              <div class="tileCell" data-tile-type="NorthWall" data-variation="3"></div>
              <div class="tileCell" data-tile-type="NorthWall" data-variation="4"></div>
            </div>
          </div>
          <!-- SouthWall -->
          <div class="tileSection" data-tile-type="SouthWall">
            <h3>SouthWall</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="SouthWall" data-variation="1"></div>
              <div class="tileCell" data-tile-type="SouthWall" data-variation="2"></div>
              <div class="tileCell" data-tile-type="SouthWall" data-variation="3"></div>
              <div class="tileCell" data-tile-type="SouthWall" data-variation="4"></div>
            </div>
          </div>
          <!-- WestWall -->
          <div class="tileSection" data-tile-type="WestWall">
            <h3>WestWall</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="WestWall" data-variation="1"></div>
              <div class="tileCell" data-tile-type="WestWall" data-variation="2"></div>
              <div class="tileCell" data-tile-type="WestWall" data-variation="3"></div>
              <div class="tileCell" data-tile-type="WestWall" data-variation="4"></div>
            </div>
          </div>
          <!-- EastWall -->
          <div class="tileSection" data-tile-type="EastWall">
            <h3>EastWall</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="EastWall" data-variation="1"></div>
              <div class="tileCell" data-tile-type="EastWall" data-variation="2"></div>
              <div class="tileCell" data-tile-type="EastWall" data-variation="3"></div>
              <div class="tileCell" data-tile-type="EastWall" data-variation="4"></div>
            </div>
          </div>
          <!-- NorthwestCorner -->
          <div class="tileSection" data-tile-type="NorthwestCorner">
            <h3>NorthwestCorner</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="NorthwestCorner" data-variation="1"></div>
              <div class="tileCell" data-tile-type="NorthwestCorner" data-variation="2"></div>
              <div class="tileCell" data-tile-type="NorthwestCorner" data-variation="3"></div>
              <div class="tileCell" data-tile-type="NorthwestCorner" data-variation="4"></div>
            </div>
          </div>
          <!-- NortheastCorner -->
          <div class="tileSection" data-tile-type="NortheastCorner">
            <h3>NortheastCorner</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="NortheastCorner" data-variation="1"></div>
              <div class="tileCell" data-tile-type="NortheastCorner" data-variation="2"></div>
              <div class="tileCell" data-tile-type="NortheastCorner" data-variation="3"></div>
              <div class="tileCell" data-tile-type="NortheastCorner" data-variation="4"></div>
            </div>
          </div>
          <!-- SouthwestCorner -->
          <div class="tileSection" data-tile-type="SouthwestCorner">
            <h3>SouthwestCorner</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="SouthwestCorner" data-variation="1"></div>
              <div class="tileCell" data-tile-type="SouthwestCorner" data-variation="2"></div>
              <div class="tileCell" data-tile-type="SouthwestCorner" data-variation="3"></div>
              <div class="tileCell" data-tile-type="SouthwestCorner" data-variation="4"></div>
            </div>
          </div>
          <!-- SoutheastCorner -->
          <div class="tileSection" data-tile-type="SoutheastCorner">
            <h3>SoutheastCorner</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="SoutheastCorner" data-variation="1"></div>
              <div class="tileCell" data-tile-type="SoutheastCorner" data-variation="2"></div>
              <div class="tileCell" data-tile-type="SoutheastCorner" data-variation="3"></div>
              <div class="tileCell" data-tile-type="SoutheastCorner" data-variation="4"></div>
            </div>
          </div>
          <!-- Door -->
          <div class="tileSection" data-tile-type="Door">
            <h3>Door</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="Door" data-variation="1"></div>
              <div class="tileCell" data-tile-type="Door" data-variation="2"></div>
              <div class="tileCell" data-tile-type="Door" data-variation="3"></div>
              <div class="tileCell" data-tile-type="Door" data-variation="4"></div>
            </div>
          </div>
          <!-- InnerTopLeft -->
          <div class="tileSection" data-tile-type="InnerTopLeft">
            <h3>InnerTopLeft</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="InnerTopLeft" data-variation="1"></div>
              <div class="tileCell" data-tile-type="InnerTopLeft" data-variation="2"></div>
              <div class="tileCell" data-tile-type="InnerTopLeft" data-variation="3"></div>
              <div class="tileCell" data-tile-type="InnerTopLeft" data-variation="4"></div>
            </div>
          </div>
          <!-- InnerTopRight -->
          <div class="tileSection" data-tile-type="InnerTopRight">
            <h3>InnerTopRight</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="InnerTopRight" data-variation="1"></div>
              <div class="tileCell" data-tile-type="InnerTopRight" data-variation="2"></div>
              <div class="tileCell" data-tile-type="InnerTopRight" data-variation="3"></div>
              <div class="tileCell" data-tile-type="InnerTopRight" data-variation="4"></div>
            </div>
          </div>
          <!-- InnerBottomLeft -->
          <div class="tileSection" data-tile-type="InnerBottomLeft">
            <h3>InnerBottomLeft</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="InnerBottomLeft" data-variation="1"></div>
              <div class="tileCell" data-tile-type="InnerBottomLeft" data-variation="2"></div>
              <div class="tileCell" data-tile-type="InnerBottomLeft" data-variation="3"></div>
              <div class="tileCell" data-tile-type="InnerBottomLeft" data-variation="4"></div>
            </div>
          </div>
          <!-- InnerBottomRight -->
          <div class="tileSection" data-tile-type="InnerBottomRight">
            <h3>InnerBottomRight</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="InnerBottomRight" data-variation="1"></div>
              <div class="tileCell" data-tile-type="InnerBottomRight" data-variation="2"></div>
              <div class="tileCell" data-tile-type="InnerBottomRight" data-variation="3"></div>
              <div class="tileCell" data-tile-type="InnerBottomRight" data-variation="4"></div>
            </div>
          </div>
          <!-- Pillar -->
          <div class="tileSection" data-tile-type="Pillar">
            <h3>Pillar (Auto‑Composite)</h3>
            <div class="tileRow">
              <div class="tileCell" data-tile-type="Pillar" data-variation="1"></div>
            </div>
          </div>
          <button id="addTileTypeBtn">Add New Tile Type</button>
        </div>
      </div>
      <div id="rightColumn">
        <!-- Sample Image Container -->
        <div id="sampleContainer">
          <div id="sampleControls">
            <p>Select a sample image or upload your own:</p>
            <select id="sampleImages">
              <option value="">-- Select Sample Image --</option>
              <option value="images/sample1.png">Sample 1</option>
              <option value="images/sample2.png">Sample 2</option>
            </select>
            <input type="file" id="uploadImage" accept="image/*">
          </div>
          <div id="imagePreviewContainer">
            <img id="imagePreview" src="" alt="Source Image" />
            <div id="nudgeControlsContainer">
              <button id="nudgeUp" class="nudgeArrow">↑</button>
              <button id="nudgeDown" class="nudgeArrow">↓</button>
              <button id="nudgeLeft" class="nudgeArrow">←</button>
              <button id="nudgeRight" class="nudgeArrow">→</button>
              <button id="confirmCropBtn">Confirm Crop</button>
              <button id="unlockCropSizeBtn">Unlock Crop Size</button>
            </div>
          </div>
        </div>
        <!-- Room Preview -->
        <div id="roomPreviewContainer">
          <h2>Room Preview</h2>
          <p>
            The preview represents a square room with passageways on all four sides.
            The outer border is set as follows:
            <br>
            • Top row (r = 0): Cell 0 is NorthwestCorner; cells 1–2 are NorthWall;
            cells 3–5 form the top passageway using:
              InnerBottomRight at cell 3, Floor at cell 4, and InnerBottomLeft at cell 5;
            cells 6–7 are NorthWall; cell 8 is NortheastCorner.
            <br>
            • Bottom row (r = 8): Cell 0 is SouthwestCorner; cells 1–2 are SouthWall;
            cells 3–5 form the bottom passageway using:
              InnerTopRight at cell 3, Floor at cell 4, and InnerTopLeft at cell 5;
            cells 6–7 are SouthWall; cell 8 is SoutheastCorner.
            <br>
            • Left column (c = 0): Cell 0 is NorthwestCorner; cells 1–2 are WestWall;
            rows 3–5 form the left passageway using:
              InnerBottomRight at row 3, Floor at row 4, and InnerTopRight at row 5;
            cells 6–7 are WestWall; cell 8 is SouthwestCorner.
            <br>
            • Right column (c = 8): Cell 0 is NortheastCorner; cells 1–2 are EastWall;
            rows 3–5 form the right passageway using:
              InnerBottomLeft at row 3, Floor at row 4, and InnerTopLeft at row 5;
            cells 6–7 are EastWall; cell 8 is SoutheastCorner.
            <br>
            • Central pillar: The central 2×2 (cells [4,4], [4,5], [5,4], [5,5]) is composed of:
              InnerTopLeft at (4,4), InnerTopRight at (4,5),
              InnerBottomLeft at (5,4), and InnerBottomRight at (5,5).
            <br>
            • An extra Pillar is forced at cell (7,7).
          </p>
          <canvas id="roomPreviewCanvas" width="1600" height="1600"></canvas>
        </div>
        <!-- Save/Load Controls -->
        <div id="saveControls">
          <h2>Save/Load Tileset</h2>
          <input type="text" id="tilesetName" placeholder="Enter tileset name" />
          <button id="randomNameBtn">Random Name</button>
          <button id="saveTilesetBtn">Save Tileset as PNG</button>
          <br>
          <button id="loadTilesetBtn">Load Tileset from PNG</button>
          <input type="file" id="loadTilesetInput" accept="image/png">
        </div>
      </div>
    </div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"
      integrity="sha512-6lplKUSl86rUVprDIjiW8DuOniNX8UDoRATqZSds/7t6zCQZfaCe3e5zcGaQwxa8Kpn5RTM9Fvl3X2lLV4grPQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script>
      // Utility functions for converting between data URL and Uint8Array.
      function dataURLToUint8Array(dataUrl) {
        const base64 = dataUrl.split(',')[1];
        const binary_string = atob(base64);
        const len = binary_string.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
      }
      function uint8ArrayToDataURL(uint8Array) {
        let binary = '';
        for (let i = 0; i < uint8Array.length; i++) {
          binary += String.fromCharCode(uint8Array[i]);
        }
        const base64 = btoa(binary);
        return 'data:image/png;base64,' + base64;
      }
      // Minimal CRC32 implementation.
      function makeCRCTable() {
        let c;
        const crcTable = [];
        for (let n = 0; n < 256; n++) {
          c = n;
          for (let k = 0; k < 8; k++) {
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
          }
          crcTable[n] = c;
        }
        return crcTable;
      }
      const crcTable = makeCRCTable();
      function crc32(buf) {
        let crc = 0 ^ (-1);
        for (let i = 0; i < buf.length; i++) {
          crc = (crc >>> 8) ^ crcTable[(crc ^ buf[i]) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
      }
      // embedMetadata: Inserts a tEXt chunk with keyword "TilesetMetadata" and the JSON metadata.
      function embedMetadata(pngDataUrl, metadata) {
        const pngBytes = dataURLToUint8Array(pngDataUrl);
        const keyword = "TilesetMetadata";
        const textEncoder = new TextEncoder();
        const textBytes = textEncoder.encode(keyword + "\0" + metadata);
        const textLength = textBytes.length;
        const chunkBuffer = new Uint8Array(4 + 4 + textLength + 4);
        // Write length
        chunkBuffer[0] = (textLength >>> 24) & 0xFF;
        chunkBuffer[1] = (textLength >>> 16) & 0xFF;
        chunkBuffer[2] = (textLength >>> 8) & 0xFF;
        chunkBuffer[3] = textLength & 0xFF;
        // Write type "tEXt"
        const typeStr = "tEXt";
        for (let i = 0; i < 4; i++) {
          chunkBuffer[4 + i] = typeStr.charCodeAt(i);
        }
        // Copy textBytes
        chunkBuffer.set(textBytes, 8);
        // Calculate CRC for chunk type and data
        const crcVal = crc32(chunkBuffer.slice(4, 8 + textLength));
        chunkBuffer[8 + textLength] = (crcVal >>> 24) & 0xFF;
        chunkBuffer[9 + textLength] = (crcVal >>> 16) & 0xFF;
        chunkBuffer[10 + textLength] = (crcVal >>> 8) & 0xFF;
        chunkBuffer[11 + textLength] = crcVal & 0xFF;
        // Find IEND chunk position
        let pos = 8;
        let iendIndex = pngBytes.length;
        while (pos < pngBytes.length) {
          const len = (pngBytes[pos] << 24) | (pngBytes[pos+1] << 16) | (pngBytes[pos+2] << 8) | pngBytes[pos+3];
          const type = String.fromCharCode(pngBytes[pos+4], pngBytes[pos+5], pngBytes[pos+6], pngBytes[pos+7]);
          if (type === "IEND") {
            iendIndex = pos;
            break;
          }
          pos += 8 + len + 4;
        }
        // Insert the new chunk before IEND
        const newPng = new Uint8Array(pngBytes.length + chunkBuffer.length);
        newPng.set(pngBytes.slice(0, iendIndex), 0);
        newPng.set(chunkBuffer, iendIndex);
        newPng.set(pngBytes.slice(iendIndex), iendIndex + chunkBuffer.length);
        return uint8ArrayToDataURL(newPng);
      }
      // parseMetadata: Extracts metadata from a tEXt chunk with keyword "TilesetMetadata"
      function parseMetadata(pngDataUrl) {
        const pngBytes = dataURLToUint8Array(pngDataUrl);
        let pos = 8;
        while (pos < pngBytes.length) {
          const len = (pngBytes[pos] << 24) | (pngBytes[pos+1] << 16) | (pngBytes[pos+2] << 8) | pngBytes[pos+3];
          const type = String.fromCharCode(pngBytes[pos+4], pngBytes[pos+5], pngBytes[pos+6], pngBytes[pos+7]);
          if (type === "tEXt") {
            const textData = pngBytes.slice(pos+8, pos+8+len);
            const text = new TextDecoder().decode(textData);
            const parts = text.split("\0");
            if (parts[0] === "TilesetMetadata") {
              return parts.slice(1).join("\0");
            }
          }
          pos += 8 + len + 4;
        }
        return "";
      }
      function downloadDataUrl(dataUrl, filename) {
        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      document.addEventListener('DOMContentLoaded', function() {
        let currentImage = null;
        let cropper = null;
        let selectedTileCell = null;
        let lastCropData = null;
        window.tilesetMetadata = {};
        window.defaultTileSizes = {};
        let cropSizeLocked = false;

        const imagePreview = document.getElementById('imagePreview');
        const sampleImagesSelect = document.getElementById('sampleImages');
        const uploadImageInput = document.getElementById('uploadImage');
        const roomPreviewCanvas = document.getElementById('roomPreviewCanvas');
        const nudgeUpBtn = document.getElementById('nudgeUp');
        const nudgeDownBtn = document.getElementById('nudgeDown');
        const nudgeLeftBtn = document.getElementById('nudgeLeft');
        const nudgeRightBtn = document.getElementById('nudgeRight');
        const confirmCropBtn = document.getElementById('confirmCropBtn');
        const nudgeControlsContainer = document.getElementById('nudgeControlsContainer');
        const unlockCropSizeBtn = document.getElementById('unlockCropSizeBtn');
        const addTileTypeBtn = document.getElementById('addTileTypeBtn');
        const tileSelector = document.getElementById('tileSelector');
        const saveTilesetBtn = document.getElementById('saveTilesetBtn');
        const loadTilesetBtn = document.getElementById('loadTilesetBtn');
        const loadTilesetInput = document.getElementById('loadTilesetInput');
        const tilesetNameInput = document.getElementById('tilesetName');
        const randomNameBtn = document.getElementById('randomNameBtn');

        const INITIAL_AUTO_CROP_AREA = 0.085;

        // Generate a random tileset name using rpg-name-generator.
        function generateRandomTilesetName() {
          if (typeof rpgNameGenerator !== "undefined" && typeof rpgNameGenerator.generate === "function") {
            // Use a random seed for each call.
            const seed = Math.random().toString(36).substring(2, 10);
            const name = rpgNameGenerator.generate({ seed: seed });
            return name;
          }
          return "Dungeon of Doom";
        }
        // Pre-populate the tileset name field on page load.
        tilesetNameInput.value = generateRandomTilesetName();
        // When the "Random Name" button is clicked, generate and set a new name.
        randomNameBtn.addEventListener('click', function() {
          tilesetNameInput.value = generateRandomTilesetName();
        });

        sampleImagesSelect.addEventListener('change', function() {
          if (this.value) {
            imagePreview.src = this.value;
            imagePreview.style.display = 'block';
            currentImage = imagePreview;
          }
        });
        uploadImageInput.addEventListener('change', function() {
          const file = this.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
              imagePreview.src = e.target.result;
              imagePreview.style.display = 'block';
              currentImage = imagePreview;
            };
            reader.readAsDataURL(file);
          }
        });

        function setupTileCells() {
          document.querySelectorAll('.tileCell').forEach(cell => {
            cell.removeEventListener('click', tileCellClickHandler);
            cell.addEventListener('click', tileCellClickHandler);
          });
        }
        function tileCellClickHandler() {
          if (cropper && selectedTileCell && selectedTileCell !== this) {
            confirmCrop();
          }
          selectedTileCell = this;
          openCropMode();
        }
        setupTileCells();

        function openCropMode() {
          nudgeControlsContainer.style.display = 'block';
          if (cropper) cropper.destroy();
          cropper = new Cropper(imagePreview, {
            aspectRatio: 1,
            viewMode: 1,
            autoCropArea: INITIAL_AUTO_CROP_AREA,
            cropBoxResizable: !cropSizeLocked,
            ready() {
              const tileType = selectedTileCell.getAttribute('data-tile-type');
              const variation = selectedTileCell.getAttribute('data-variation');
              const variantIndex = parseInt(variation) - 1;
              let storedCropData = null;
              if (
                window.tilesetMetadata[tileType] &&
                window.tilesetMetadata[tileType].variations[variantIndex] &&
                window.tilesetMetadata[tileType].variations[variantIndex].cropData
              ) {
                storedCropData = window.tilesetMetadata[tileType].variations[variantIndex].cropData;
              } else if (lastCropData) {
                storedCropData = lastCropData;
              }
              if (storedCropData) {
                cropper.setData(storedCropData);
              }
            }
          });
        }

        if (unlockCropSizeBtn) {
          unlockCropSizeBtn.addEventListener('click', function() {
            cropSizeLocked = false;
            openCropMode();
            unlockCropSizeBtn.style.display = 'none';
          });
        }

        function addClearButton(cell) {
          const existingClear = cell.querySelector('.clearButton');
          if (existingClear) {
            existingClear.remove();
          }
          if (cell.innerHTML.indexOf("img") !== -1) {
            const clearBtn = document.createElement('button');
            clearBtn.textContent = "X";
            clearBtn.className = "clearButton";
            clearBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              cell.innerHTML = "";
              const tileType = cell.getAttribute('data-tile-type');
              const idx = parseInt(cell.getAttribute('data-variation')) - 1;
              window.tilesetMetadata[tileType] = window.tilesetMetadata[tileType] || { variations: [] };
              window.tilesetMetadata[tileType].variations[idx] = {
                variation: cell.getAttribute('data-variation'),
                imageData: "",
                width: 0,
                height: 0,
                cropData: null
              };
              updateRoomPreview();
            });
            cell.appendChild(clearBtn);
          }
        }

        function refreshActiveTilePreview() {
          if (cropper && selectedTileCell) {
            let canvas = cropper.getCroppedCanvas();
            const newImage = canvas.toDataURL('image/png');
            selectedTileCell.innerHTML = '<img src="' + newImage + '" alt="Tile Variant">';
            addClearButton(selectedTileCell);
            const tileType = selectedTileCell.getAttribute('data-tile-type');
            const variantIndex = parseInt(selectedTileCell.getAttribute('data-variation')) - 1;
            window.tilesetMetadata[tileType] = window.tilesetMetadata[tileType] || { variations: [] };
            window.tilesetMetadata[tileType].variations[variantIndex] = {
              variation: selectedTileCell.getAttribute('data-tile-type'),
              imageData: newImage,
              width: canvas.width,
              height: canvas.height,
              cropData: cropper.getData(true)
            };
            updateRoomPreview();
          }
        }

        nudgeUpBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.y -= 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeDownBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.y += 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeLeftBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.x -= 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });
        nudgeRightBtn.addEventListener('click', function() {
          if (cropper) {
            let data = cropper.getData(true);
            data.x += 1;
            cropper.setData(data);
            refreshActiveTilePreview();
          }
        });

        confirmCropBtn.addEventListener('click', confirmCrop);

        function confirmCrop() {
          if (cropper) {
            let canvas = cropper.getCroppedCanvas();
            const tileType = selectedTileCell.getAttribute('data-tile-type');
            const cropData = cropper.getData(true);
            lastCropData = cropData;
            if (!window.defaultTileSizes[tileType]) {
              window.defaultTileSizes[tileType] = { width: canvas.width, height: canvas.height };
            } else {
              const defaultWidth = window.defaultTileSizes[tileType].width;
              const defaultHeight = window.defaultTileSizes[tileType].height;
              if (canvas.width !== defaultWidth || canvas.height !== defaultHeight) {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = defaultWidth;
                offCanvas.height = defaultHeight;
                const offCtx = offCanvas.getContext('2d');
                offCtx.drawImage(canvas, 0, 0, defaultWidth, defaultHeight);
                canvas = offCanvas;
              }
            }
            const croppedDataUrl = canvas.toDataURL('image/png');
            selectedTileCell.innerHTML = '<img src="' + croppedDataUrl + '" alt="Tile Variant">';
            addClearButton(selectedTileCell);
            const tileTypeKey = selectedTileCell.getAttribute('data-tile-type');
            window.tilesetMetadata[tileTypeKey] = window.tilesetMetadata[tileTypeKey] || { variations: [] };
            const variantIndex = parseInt(selectedTileCell.getAttribute('data-variation')) - 1;
            window.tilesetMetadata[tileTypeKey].variations[variantIndex] = {
              variation: selectedTileCell.getAttribute('data-tile-type'),
              imageData: croppedDataUrl,
              width: canvas.width,
              height: canvas.height,
              cropData: cropData
            };
            cropSizeLocked = true;
            if (unlockCropSizeBtn) {
              unlockCropSizeBtn.style.display = 'block';
            }
            cropper.destroy();
            cropper = null;
            nudgeControlsContainer.style.display = 'none';
            updateRoomPreview();
          }
        }

        function drawCheckeredBackground(ctx, width, height, tileSize) {
          const lightColor = "#555";
          const darkColor = "#333";
          for (let y = 0; y < height; y += tileSize) {
            for (let x = 0; x < width; x += tileSize) {
              const isDark = ((x / tileSize) + (y / tileSize)) % 2 === 0;
              ctx.fillStyle = isDark ? darkColor : lightColor;
              ctx.fillRect(x, y, tileSize, tileSize);
            }
          }
        }

        // Room Preview Layout (unchanged)
        function updateRoomPreview() {
          if (!roomPreviewCanvas) return;
          const ctx = roomPreviewCanvas.getContext('2d');
          const gridSize = 9;
          const tileSize = window.defaultTileSizes["Floor"] ? window.defaultTileSizes["Floor"].width : 80;
          roomPreviewCanvas.width = gridSize * tileSize;
          roomPreviewCanvas.height = gridSize * tileSize;
          ctx.clearRect(0, 0, roomPreviewCanvas.width, roomPreviewCanvas.height);
          drawCheckeredBackground(ctx, roomPreviewCanvas.width, roomPreviewCanvas.height, tileSize);
          
          for (let r = 0; r < gridSize; r++) {
            for (let c = 0; c < gridSize; c++) {
              let tileType;
              if (r === 0) { // top row
                if (c === 0) {
                  tileType = "NorthwestCorner";
                } else if (c === gridSize - 1) {
                  tileType = "NortheastCorner";
                } else if (c >= 3 && c <= 5) { // top passageway
                  if (c === 3) tileType = "InnerBottomRight";
                  else if (c === 5) tileType = "InnerBottomLeft";
                  else tileType = "Floor";
                } else {
                  tileType = "NorthWall";
                }
              } else if (r === gridSize - 1) { // bottom row
                if (c === 0) {
                  tileType = "SouthwestCorner";
                } else if (c === gridSize - 1) {
                  tileType = "SoutheastCorner";
                } else if (c >= 3 && c <= 5) { // bottom passageway
                  if (c === 3) tileType = "InnerTopRight";
                  else if (c === 5) tileType = "InnerTopLeft";
                  else tileType = "Floor";
                } else {
                  tileType = "SouthWall";
                }
              } else if (c === 0) { // left column
                if (r === 0 || r === gridSize - 1) {
                  tileType = undefined;
                } else if (r >= 3 && r <= 5) { // left passageway
                  if (r === 3) tileType = "InnerBottomRight";
                  else if (r === 5) tileType = "InnerTopRight";
                  else tileType = "Floor";
                } else {
                  tileType = "WestWall";
                }
              } else if (c === gridSize - 1) { // right column
                if (r === 0 || r === gridSize - 1) {
                  tileType = undefined;
                } else if (r >= 3 && r <= 5) { // right passageway
                  if (r === 3) tileType = "InnerBottomLeft";
                  else if (r === 5) tileType = "InnerTopLeft";
                  else tileType = "Floor";
                } else {
                  tileType = "EastWall";
                }
              } else {
                // Inner region
                if (r === 4 && c === 4) {
                  tileType = "InnerTopLeft";
                } else if (r === 4 && c === 5) {
                  tileType = "InnerTopRight";
                } else if (r === 5 && c === 4) {
                  tileType = "InnerBottomLeft";
                } else if (r === 5 && c === 5) {
                  tileType = "InnerBottomRight";
                } else if (r === 7 && c === 7) {
                  tileType = "Pillar";
                } else {
                  tileType = "Floor";
                }
              }
              if (!tileType) continue;
              
              let variants = window.tilesetMetadata[tileType]?.variations;
              let variant = null;
              if (variants && variants.length > 0) {
                variant = variants[Math.floor(Math.random() * variants.length)].imageData;
              }
              if (!variant && tileType !== "Floor" && window.tilesetMetadata["Floor"]?.variations?.length > 0) {
                variant = window.tilesetMetadata["Floor"].variations[0].imageData;
              }
              const x = c * tileSize;
              const y = r * tileSize;
              if (variant) {
                const img = new Image();
                img.src = variant;
                img.onload = (function(x, y) {
                  return function() {
                    ctx.drawImage(this, x, y, tileSize, tileSize);
                  };
                })(x, y);
              } else {
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.font = "12px Segoe UI";
                ctx.fillText(tileType, x + 5, y + 15);
              }
            }
          }
        }

        document.addEventListener('click', function(e) {
          if (cropper && !e.target.closest('#imagePreviewContainer') && !e.target.closest('.tileCell')) {
            confirmCrop();
          }
        });

        addTileTypeBtn.addEventListener('click', function() {
          const newType = prompt("Enter the new tile type name:");
          if (newType && newType.trim() !== "") {
            const section = document.createElement('div');
            section.className = 'tileSection';
            section.setAttribute('data-tile-type', newType);
            const header = document.createElement('h3');
            header.textContent = newType;
            section.appendChild(header);
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            const row = document.createElement('div');
            row.className = 'tileRow';
            for (let i = 1; i <= 4; i++) {
              const cell = document.createElement('div');
              cell.className = 'tileCell';
              cell.setAttribute('data-tile-type', newType);
              cell.setAttribute('data-variation', i);
              row.appendChild(cell);
              cell.addEventListener('click', function() {
                if (cropper && selectedTileCell && selectedTileCell !== this) {
                  confirmCrop();
                }
                selectedTileCell = this;
                openCropMode();
              });
            }
            container.appendChild(row);
            section.appendChild(container);
            tileSelector.appendChild(section);
            setupTileCells();
          }
        });

        // Save Tileset: embed metadata and trigger download
        saveTilesetBtn.addEventListener('click', function() {
          const tilesetName = tilesetNameInput.value.trim() || "tileset";
          const pngDataUrl = roomPreviewCanvas.toDataURL("image/png");
          const metadata = JSON.stringify(window.tilesetMetadata);
          const pngWithMetadata = embedMetadata(pngDataUrl, metadata);
          downloadDataUrl(pngWithMetadata, tilesetName + ".png");
        });

        // Load Tileset: extract metadata and populate empty tile cells
        loadTilesetBtn.addEventListener('click', function() {
          loadTilesetInput.click();
        });
        loadTilesetInput.addEventListener('change', function() {
          const file = this.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
              const dataUrl = e.target.result;
              const metadata = parseMetadata(dataUrl);
              if (metadata) {
                window.tilesetMetadata = JSON.parse(metadata);
                document.querySelectorAll('.tileCell').forEach(cell => {
                  const type = cell.getAttribute('data-tile-type');
                  const idx = parseInt(cell.getAttribute('data-variation')) - 1;
                  if (!cell.innerHTML && window.tilesetMetadata[type] && window.tilesetMetadata[type].variations[idx] && window.tilesetMetadata[type].variations[idx].imageData) {
                    cell.innerHTML = '<img src="' + window.tilesetMetadata[type].variations[idx].imageData + '" alt="Tile Variant">';
                    addClearButton(cell);
                  }
                });
                updateRoomPreview();
              } else {
                console.error("No metadata found in the loaded PNG.");
              }
            };
            reader.readAsDataURL(file);
          }
        });

        // embedMetadata: Inserts a tEXt chunk with keyword "TilesetMetadata" and the JSON metadata.
        function embedMetadata(pngDataUrl, metadata) {
          const pngBytes = dataURLToUint8Array(pngDataUrl);
          const keyword = "TilesetMetadata";
          const textEncoder = new TextEncoder();
          const textBytes = textEncoder.encode(keyword + "\0" + metadata);
          const textLength = textBytes.length;
          const chunkBuffer = new Uint8Array(4 + 4 + textLength + 4);
          // Write length
          chunkBuffer[0] = (textLength >>> 24) & 0xFF;
          chunkBuffer[1] = (textLength >>> 16) & 0xFF;
          chunkBuffer[2] = (textLength >>> 8) & 0xFF;
          chunkBuffer[3] = textLength & 0xFF;
          // Write type "tEXt"
          const typeStr = "tEXt";
          for (let i = 0; i < 4; i++) {
            chunkBuffer[4 + i] = typeStr.charCodeAt(i);
          }
          // Copy textBytes
          chunkBuffer.set(textBytes, 8);
          // Calculate CRC for chunk type and data
          const crcVal = crc32(chunkBuffer.slice(4, 8 + textLength));
          chunkBuffer[8 + textLength] = (crcVal >>> 24) & 0xFF;
          chunkBuffer[9 + textLength] = (crcVal >>> 16) & 0xFF;
          chunkBuffer[10 + textLength] = (crcVal >>> 8) & 0xFF;
          chunkBuffer[11 + textLength] = crcVal & 0xFF;
          // Find IEND chunk position
          let pos = 8;
          let iendIndex = pngBytes.length;
          while (pos < pngBytes.length) {
            const len = (pngBytes[pos] << 24) | (pngBytes[pos+1] << 16) | (pngBytes[pos+2] << 8) | pngBytes[pos+3];
            const type = String.fromCharCode(pngBytes[pos+4], pngBytes[pos+5], pngBytes[pos+6], pngBytes[pos+7]);
            if (type === "IEND") {
              iendIndex = pos;
              break;
            }
            pos += 8 + len + 4;
          }
          // Insert the new chunk before IEND
          const newPng = new Uint8Array(pngBytes.length + chunkBuffer.length);
          newPng.set(pngBytes.slice(0, iendIndex), 0);
          newPng.set(chunkBuffer, iendIndex);
          newPng.set(pngBytes.slice(iendIndex), iendIndex + chunkBuffer.length);
          return uint8ArrayToDataURL(newPng);
        }
        // parseMetadata: Extracts metadata from a tEXt chunk with keyword "TilesetMetadata"
        function parseMetadata(pngDataUrl) {
          const pngBytes = dataURLToUint8Array(pngDataUrl);
          let pos = 8;
          while (pos < pngBytes.length) {
            const len = (pngBytes[pos] << 24) | (pngBytes[pos+1] << 16) | (pngBytes[pos+2] << 8) | pngBytes[pos+3];
            const type = String.fromCharCode(pngBytes[pos+4], pngBytes[pos+5], pngBytes[pos+6], pngBytes[pos+7]);
            if (type === "tEXt") {
              const textData = pngBytes.slice(pos+8, pos+8+len);
              const text = new TextDecoder().decode(textData);
              const parts = text.split("\0");
              if (parts[0] === "TilesetMetadata") {
                return parts.slice(1).join("\0");
              }
            }
            pos += 8 + len + 4;
          }
          return "";
        }
        function downloadDataUrl(dataUrl, filename) {
          const link = document.createElement("a");
          link.href = dataUrl;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      });
    </script>
  </body>
</html>
